//+------------------------------------------------------------------+
//|                                      moneyManagement_v7.mq5      |
//|                                  Copyright 2024, TraderAssistant |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, TraderAssistant"
#property version   "7.00"
#property description "TraderAssistant - Pips Based Version"

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>

//--- 入力パラメータ
input group "=== 基本設定 ==="
input double   DefaultRRRatio = 5.0;        // デフォルトRR比
input bool     EnableSplitEntry = true;     // 分割エントリー
input int      SplitCount = 2;              // 分割数
input int      DailyTradeLimit = 4;         // 日次トレード上限

input group "=== 自動決済設定 ==="
input bool     EnableAutoClose = true;      // 自動決済を有効化
input double   AutoClosePips = 200.0;       // 合計獲得pips（自動決済）
input double   AutoCloseMoney = 3000.0;     // 合計獲得金額（自動決済）
input bool     CloseOnlyProfit = true;      // 利益ポジションのみ決済

input group "=== パネル設定 ==="
input int      PanelPosX = 20;             // パネルX位置
input int      PanelPosY = 50;             // パネルY位置

//--- グローバル変数
CTrade trade;
CPositionInfo position;
CDealInfo deal;
enum PHASE_STAGE
{
    STAGE_EARLY = 0,    // 序盤
    STAGE_MID = 1,      // 中盤
    STAGE_LATE = 2      // 終盤
};

struct PhaseInfo
{
    int phase;
    int stage;
    double startBalance;
    double endBalance;
    string stageName;
    string phaseTitle;
    double riskPercent;
    double maxRisk;
};

int currentStage;
PhaseInfo phaseData[15] = {
    // Phase 1: 土台構築期 (5K-20K)
    {1, STAGE_EARLY, 5000, 8000, "初級", "P1", 7.0, 400},
    {1, STAGE_MID, 8000, 12000, "中級", "P1", 7.0, 400},
    {1, STAGE_LATE, 12000, 20000, "上級", "P1", 7.0, 400},
    
    // Phase 2: 安定化期 (20K-50K)
    {2, STAGE_EARLY, 20000, 28000, "初級", "P2", 6.0, 800},
    {2, STAGE_MID, 28000, 38000, "中級", "P2", 6.0, 800},
    {2, STAGE_LATE, 38000, 50000, "上級", "P2", 6.0, 800},
    
    // Phase 3: 発展期 (50K-150K)
    {3, STAGE_EARLY, 50000, 75000, "初級", "P3", 5.0, 1500},
    {3, STAGE_MID, 75000, 110000, "中級", "P3", 5.0, 1500},
    {3, STAGE_LATE, 110000, 150000, "上級", "P3", 5.0, 1500},
    
    // Phase 4: 拡大期 (150K-500K)
    {4, STAGE_EARLY, 150000, 250000, "初級", "P4", 4.0, 3000},
    {4, STAGE_MID, 250000, 375000, "中級", "P4", 4.0, 3000},
    {4, STAGE_LATE, 375000, 500000, "上級", "P4", 4.0, 3000},
    
    // Phase 5: 成熟期 (500K-3M)
    {5, STAGE_EARLY, 500000, 1000000, "初級", "P5", 3.0, 5000},
    {5, STAGE_MID, 1000000, 2000000, "中級", "P5", 3.0, 8000},
    {5, STAGE_LATE, 2000000, 3000000, "上級", "P5", 3.0, 10000}
};

string badges[15] = {
    "Lv1", "Lv2", "Lv3",      // Phase 1
    "Lv4", "Lv5", "Lv6",      // Phase 2  
    "Lv7", "Lv8", "Lv9",      // Phase 3
    "Lv10", "Lv11", "Lv12",   // Phase 4
    "Lv13", "Lv14", "Lv15"    // Phase 5
};

static double lastBalance = 0; // レベルアップチェック用
double accountBalance, currentRiskPercent, currentMaxRisk;
int currentPhase;

// LOT計算用変数
double inputSLPips = 20.0;      // デフォルトSL pips
double inputTPPips = 100.0;     // デフォルトTP pips
double inputRiskAmount = 0.0;   // 手動入力リスク額
double inputRiskPercent = 0.0;  // 手動入力リスク率
double calculatedLot = 0.0;
double riskAmount = 0.0;
double recommendedRiskAmount = 0.0; // 推奨リスク額

// ポジション管理
double totalProfit = 0;
double totalPips = 0;
int positionCount = 0;

// 日次管理
int todayTradeCount = 0;
double todayProfit = 0;
datetime lastDayCheck = 0;

// 統計管理
struct TradeStats {
    int totalTrades;
    int winTrades;
    double totalRR;
    double weeklyProfit;
    double monthlyProfit;
};
TradeStats stats;

// エディットボックス名
string slPipsEditName = "PC_EditSLPips";
string tpPipsEditName = "PC_EditTPPips";
string riskAmountEditName = "PC_EditRiskAmount";
string riskPercentEditName = "PC_EditRiskPercent";

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    trade.SetExpertMagicNumber(123456);
    CreateEnhancedPanel();
    LoadTradeStats();
    UpdateAll();
    EventSetTimer(1);
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    EventKillTimer();
    ObjectsDeleteAll(0, "PC_");
    SaveTradeStats();
}

//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
{
    UpdateAll();
    CheckAutoClose();
    CheckDailyReset();
    // レベルアップチェック
    if(lastBalance > 0)
    {
        CheckLevelUp(lastBalance, accountBalance);
    }
    lastBalance = accountBalance;
}

//+------------------------------------------------------------------+
//| Trade function                                                   |
//+------------------------------------------------------------------+
void OnTrade()
{
    UpdatePositionInfo();
}

//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    // ボタンクリックイベント
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        // LOT計算関連
        if(sparam == "PC_BtnCalcLot") { CalculateLotFromPips(); UpdateAll(); }
        else if(sparam == "PC_BtnBuyMarket") ExecuteMarketOrder(true);
        else if(sparam == "PC_BtnSellMarket") ExecuteMarketOrder(false);
        
        // ポジション管理ボタン
        else if(sparam == "PC_BtnCloseAll") CloseAllPositions();
        else if(sparam == "PC_BtnCloseProfit") CloseProfitPositions();
        else if(sparam == "PC_BtnCloseLoss") CloseLossPositions();
        else if(sparam == "PC_BtnBreakeven") MoveAllToBreakeven();
        else if(sparam == "PC_BtnModifySL") ModifyAllPositionsSL();
        else if(sparam == "PC_BtnModifyTP") ModifyAllPositionsTP();
    }
    
    // エディットボックスの値変更
    if(id == CHARTEVENT_OBJECT_ENDEDIT)
    {
        if(sparam == slPipsEditName || sparam == tpPipsEditName || 
           sparam == riskAmountEditName || sparam == riskPercentEditName)
        {
            ReadPipsInput();
        }
    }
}

//+------------------------------------------------------------------+
//| 拡張版パネル作成                                                 |
//+------------------------------------------------------------------+
void CreateEnhancedPanel()
{
    int x = PanelPosX;
    int y = PanelPosY;
    int width = 850;
    int lineHeight = 55;      // 50 → 55
    int sectionGap = 40;      // 30 → 40（セクション間の余白を増加）
    int padding = 25;
    
       color bgColor = C'25,27,30';
    color sectionBg = C'35,37,40';
    color headerBg = C'45,55,72';
    color textColor = C'220,220,220';
    color labelColor = C'160,160,160';
    color greenColor = C'76,175,80';
    color redColor = C'244,67,54';
    color blueColor = C'33,150,243';
    color orangeColor = C'255,152,0';

    // メイン背景（高さを大幅に増加）
    CreateRect("PC_MainBg", x, y, width, 1500, bgColor);  // 1250 → 1500
    
    // ヘッダー
    CreateRect("PC_Header", x, y, width, 60, headerBg);   // 50 → 60
    CreateLabel("PC_Title", x + width/2, y + 20, "MT5 Trade Management System - Pips Version", 
                16, clrWhite, "Arial Bold", ANCHOR_CENTER);   // y+15 → y+20
    
    y += 70;  // 65 → 70
    
    // === アカウント情報セクション ===
    int accountSectionHeight = 160;  // 140 → 160
    CreateSection(x, y, width, accountSectionHeight, "アカウント情報", sectionBg);
    
    // 内容の配置（Y座標を調整してセクション内に収める）
    CreateLabel("PC_LblPhase", x + padding, y + 55, "Phase", 12, labelColor);
    CreateLabel("PC_ValPhase", x + 130, y + 55, "1", 12, greenColor, "Arial Bold");
    
    CreateLabel("PC_LblBalance", x + 350, y + 55, "残高", 12, labelColor);
    CreateLabel("PC_ValBalance", x + 500, y + 55, "0円", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblRisk", x + padding, y + 100, "Risk", 12, labelColor);
    CreateLabel("PC_ValRisk", x + 110, y + 100, "0%", 12, redColor, "Arial Bold");
    
    CreateLabel("PC_LblMaxRisk", x + 250, y + 100, "Max Risk", 12, labelColor);
    CreateLabel("PC_ValMaxRisk", x + 420, y + 100, "0円", 12, redColor, "Arial Bold");
    
    // プログレスバー（セクション内に収まるよう調整）
       CreateLabel("PC_PhaseProgressLabel", x + 620, y + 15, "サブフェーズ進捗", 10, labelColor);
    CreateProgressBar("PC_PhaseProgress", x + 620, y + 55, 180, 25,
                      GetSubPhaseProgress(), C'52,152,219', C'60,60,60');
    
    CreateLabel("PC_OverallProgressLabel", x + 620, y + 125, "全体進捗", 9, labelColor);
    CreateProgressBar("PC_OverallProgress", x + 620, y + 100, 180, 20,
                      GetOverallProgress(), C'76,175,80', C'60,60,60');
    
    y += accountSectionHeight + sectionGap;
    
    // === 日次管理セクション ===
    int dailySectionHeight = 150;  // 120 → 150
    CreateSection(x, y, width, dailySectionHeight, "日次管理", sectionBg);
    
    CreateLabel("PC_LblTodayTrades", x + padding, y + 55, "本日取引", 12, labelColor);
    CreateLabel("PC_ValTodayTrades", x + 200, y + 55, "0/3", 12, blueColor, "Arial Bold");
    
    CreateLabel("PC_LblTodayPL", x + 280, y + 55, "日次損益", 12, labelColor);
    CreateLabel("PC_ValTodayPL", x + 480, y + 55, "0円", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblTradeStatus", x + padding, y + 100, "取引状態", 12, labelColor);
    CreateLabel("PC_ValTradeStatus", x + 160, y + 100, "取引可能", 12, greenColor, "Arial Bold");
    
    y += dailySectionHeight + sectionGap;
    
    // === ポジション状況セクション ===
    int positionSectionHeight = 150;  // 120 → 150
    CreateSection(x, y, width, positionSectionHeight, "ポジション状況", sectionBg);
    
    CreateLabel("PC_LblPosCount", x + padding, y + 55, "保有数", 12, labelColor);
    CreateLabel("PC_ValPosCount", x + 140, y + 55, "0", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblPL", x + 200, y + 55, "損益", 12, labelColor);
    CreateLabel("PC_ValPL", x + 280, y + 55, "0円", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblPips", x + padding, y + 100, "Pips", 12, labelColor);
    CreateLabel("PC_ValPips", x + 100, y + 100, "0.0", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblAuto", x + 200, y + 100, "自動決済", 12, labelColor);
    CreateLabel("PC_ValAuto", x + 380, y + 100, "OFF", 12, greenColor, "Arial Bold");
    
    y += positionSectionHeight + sectionGap;
    
    // === 統計情報セクション ===
    int statsSectionHeight = 150;  // 120 → 150
    CreateSection(x, y, width, statsSectionHeight, "統計情報", sectionBg);
    
    CreateLabel("PC_LblWinRate", x + padding, y + 55, "直近10勝率", 12, labelColor);
    CreateLabel("PC_ValWinRate", x + 210, y + 55, "0%", 12, blueColor, "Arial Bold");
    
    CreateLabel("PC_LblAvgRR", x + 330, y + 55, "平均RR比", 12, labelColor);
    CreateLabel("PC_ValAvgRR", x + 550, y + 55, "0.0", 12, blueColor, "Arial Bold");
    
    CreateLabel("PC_LblWeekly", x + padding, y + 100, "週次損益", 12, labelColor);
    CreateLabel("PC_ValWeekly", x + 180, y + 100, "0円", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblMonthly", x + 330, y + 100, "月次損益", 12, labelColor);
    CreateLabel("PC_ValMonthly", x + 550, y + 100, "0円", 12, textColor, "Arial Bold");
    
    y += statsSectionHeight + sectionGap;
    
    // === LOT計算セクション ===
    int lotSectionHeight = 280;
    CreateSection(x, y, width, lotSectionHeight, "LOT計算", sectionBg);

    // SL pips入力
    CreateLabel("PC_LblSLPips", x + padding, y + 40, "S/L pips", 13, labelColor);
    CreateEditBox(slPipsEditName, x + 160, y + 45, 100, 30, 
                DoubleToString(inputSLPips, 1), 14, textColor, sectionBg);

    // TP pips入力
    CreateLabel("PC_LblTPPips", x + 280, y + 40, "T/P pips", 13, labelColor);
    CreateEditBox(tpPipsEditName, x + 430, y + 45, 100, 30, 
                DoubleToString(inputTPPips, 1), 14, textColor, sectionBg);

    // リスク額入力
    CreateLabel("PC_LblRiskAmount", x + padding, y + 85, "損失額", 13, labelColor);
    CreateEditBox(riskAmountEditName, x + 160, y + 90, 100, 30, 
                "0", 14, textColor, sectionBg);
    CreateLabel("PC_LblRiskAmountYen", x + 255, y + 90, "円", 13, labelColor);

    // リスク率入力
    CreateLabel("PC_LblRiskPercent", x + 300, y + 85, "損失率", 13, labelColor);
    CreateEditBox(riskPercentEditName, x + 420, y + 95, 100, 30, 
                "0", 14, textColor, sectionBg);
    CreateLabel("PC_LblRiskPercentMark", x + 485, y + 85, "%", 13, labelColor);

    // 推奨値表示
    CreateLabel("PC_LblRecommend", x + padding, y + 125, "推奨リスク", 13, labelColor);
    CreateLabel("PC_ValRecommend", x + 220, y + 125, "---", 12, C'100,150,250', "Arial");

    // 計算結果表示
    CreateLabel("PC_LblCalcRisk", x + padding, y + 155, "使用リスク額", 13, labelColor);
    CreateLabel("PC_ValCalcRisk", x + 240, y + 155, "---", 13, redColor, "Arial Bold");

    CreateLabel("PC_LblCalcLot", x + 430, y + 155, "推奨LOT", 13, labelColor);
    CreateLabel("PC_ValCalcLot", x + 570, y + 145, "---", 15, greenColor, "Arial Black");

    // LOT計算ボタン
    CreateButton("PC_BtnCalcLot", x + padding, y + 200, 200, 40, "LOT計算", greenColor);

    // マーケット注文ボタン
    CreateButton("PC_BtnBuyMarket", x + 230, y + 200, 180, 40, "BUY 成行", blueColor);
    CreateButton("PC_BtnSellMarket", x + 420, y + 200, 180, 40, "SELL 成行", redColor);

    // 分割エントリー表示
    CreateLabel("PC_LblSplitInfo", x + padding, y + 255, 
                "分割エントリー: " + (EnableSplitEntry ? "ON (" + IntegerToString(SplitCount) + "分割)" : "OFF"), 
                11, labelColor);

    y += lotSectionHeight + sectionGap;
    
    // === ポジション管理セクション ===
    int manageSectionHeight = 210;
    CreateSection(x, y, width, manageSectionHeight, "ポジション管理", sectionBg);

    // SL/TP一括変更
    CreateLabel("PC_LblModify", x + padding, y + 40, "既存ポジションのSL/TP一括変更", 12, labelColor);
    CreateButton("PC_BtnModifySL", x + padding, y + 65, 295, 35, "全ポジSL変更", orangeColor);
    CreateButton("PC_BtnModifyTP", x + 335, y + 65, 295, 35, "全ポジTP変更", orangeColor);

    // 決済ボタン
    CreateButton("PC_BtnCloseAll", x + padding, y + 110, 295, 35, "全ポジション決済", redColor);
    CreateButton("PC_BtnBreakeven", x + 335, y + 110, 295, 35, "建値ストップ", blueColor);

    CreateButton("PC_BtnCloseProfit", x + padding, y + 155, 295, 35, "利益のみ決済", greenColor);
    CreateButton("PC_BtnCloseLoss", x + 335, y + 155, 295, 35, "損失のみ決済", orangeColor);

    y += manageSectionHeight + sectionGap;
    
    // === 操作方法 ===
    int helpSectionHeight = 100;  // 80 → 100
    CreateSection(x, y, width, helpSectionHeight, "操作方法", sectionBg);
    
    CreateLabel("PC_Help1", x + padding, y + 40,   // y+35 → y+40
                "• SL/TP pipsを入力してLOT計算 → 成行注文", 
                11, labelColor);
    CreateLabel("PC_Help2", x + padding, y + 65,   // y+55 → y+65
                "• 自動決済: " + DoubleToString(AutoClosePips, 1) + "pips / " + 
                DoubleToString(AutoCloseMoney, 0) + "円", 
                11, labelColor);
}

//+------------------------------------------------------------------+
//| エディットボックス作成                                           |
//+------------------------------------------------------------------+
void CreateEditBox(string name, int x, int y, int w, int h, string text, 
                   int fontSize, color textColor, color bgColor)
{
    ObjectCreate(0, name, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
    ObjectSetInteger(0, name, OBJPROP_COLOR, textColor);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, C'100,100,100');
    ObjectSetInteger(0, name, OBJPROP_ALIGN, ALIGN_CENTER);
}

//+------------------------------------------------------------------+
//| Pips入力値読み取り                                               |
//+------------------------------------------------------------------+
void ReadPipsInput()
{
    string slText = ObjectGetString(0, slPipsEditName, OBJPROP_TEXT);
    string tpText = ObjectGetString(0, tpPipsEditName, OBJPROP_TEXT);
    string riskAmountText = ObjectGetString(0, riskAmountEditName, OBJPROP_TEXT);
    string riskPercentText = ObjectGetString(0, riskPercentEditName, OBJPROP_TEXT);
    
    inputSLPips = StringToDouble(slText);
    inputTPPips = StringToDouble(tpText);
    inputRiskAmount = StringToDouble(riskAmountText);
    inputRiskPercent = StringToDouble(riskPercentText);
    
    // 値の検証
    if(inputSLPips <= 0) inputSLPips = 20.0;
    if(inputTPPips <= 0) inputTPPips = 100.0;
    if(inputRiskAmount < 0) inputRiskAmount = 0;
    if(inputRiskPercent < 0) inputRiskPercent = 0;
}

//+------------------------------------------------------------------+
//| Pipsベースでのロット計算                                         |
//+------------------------------------------------------------------+
void CalculateLotFromPips()
{
    ReadPipsInput();
    
    // 推奨リスク額の計算（表示用）
    recommendedRiskAmount = MathMin(accountBalance * currentRiskPercent / 100, currentMaxRisk);
    recommendedRiskAmount = recommendedRiskAmount / DailyTradeLimit;
    
    // 前日マイナス時の推奨値調整
    if(todayProfit < 0) {
        recommendedRiskAmount = recommendedRiskAmount / 2;
    }
    
    // 実際に使用するリスク額の決定
    if(inputRiskAmount > 0) {
        // 手動入力額を優先
        riskAmount = inputRiskAmount;
    }
    else if(inputRiskPercent > 0) {
        // 手動入力率から計算
        riskAmount = accountBalance * inputRiskPercent / 100;
    }
    else {
        // どちらも入力されていない場合は推奨値を使用
        riskAmount = recommendedRiskAmount;
        Alert("リスク額が入力されていないため、推奨値を使用します: " + 
              IntegerToString((int)riskAmount) + "円");
    }
    
    // ロット計算
    double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    double onePipValue = tickValue * 10;
    
    calculatedLot = riskAmount / (inputSLPips * onePipValue);
    
    // ロット調整
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
    calculatedLot = MathFloor(calculatedLot / lotStep) * lotStep;
    calculatedLot = MathMax(minLot, MathMin(maxLot, calculatedLot));
    
    Comment("LOT計算完了: " + DoubleToString(calculatedLot, 2) + 
            " (SL: " + DoubleToString(inputSLPips, 1) + "pips, " +
            "TP: " + DoubleToString(inputTPPips, 1) + "pips, " +
            "リスク: " + IntegerToString((int)riskAmount) + "円)");
}

//+------------------------------------------------------------------+
//| 成行注文実行                                                     |
//+------------------------------------------------------------------+
void ExecuteMarketOrder(bool isBuy)
{
    // 日次上限チェック
    if(todayTradeCount >= DailyTradeLimit) {
        Alert("日次トレード上限に達しています");
        return;
    }
    
    if(calculatedLot == 0) {
        Alert("先にLOT計算してください");
        return;
    }
    
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    double sl, tp;
    
    if(EnableSplitEntry && SplitCount > 1)
    {
        double lotPerTrade = calculatedLot / SplitCount;
        for(int i = 0; i < SplitCount; i++)
        {
            if(isBuy)
            {
                sl = ask - inputSLPips * point * 10;
                tp = ask + inputTPPips * point * 10;
                trade.Buy(lotPerTrade, _Symbol, 0, sl, tp, 
                         "Split " + IntegerToString(i+1) + "/" + IntegerToString(SplitCount));
            }
            else
            {
                sl = bid + inputSLPips * point * 10;
                tp = bid - inputTPPips * point * 10;
                trade.Sell(lotPerTrade, _Symbol, 0, sl, tp,
                          "Split " + IntegerToString(i+1) + "/" + IntegerToString(SplitCount));
            }
        }
    }
    else
    {
        if(isBuy)
        {
            sl = ask - inputSLPips * point * 10;
            tp = ask + inputTPPips * point * 10;
            trade.Buy(calculatedLot, _Symbol, 0, sl, tp);
        }
        else
        {
            sl = bid + inputSLPips * point * 10;
            tp = bid - inputTPPips * point * 10;
            trade.Sell(calculatedLot, _Symbol, 0, sl, tp);
        }
    }
    
    todayTradeCount++;
    calculatedLot = 0; // リセット
}

//+------------------------------------------------------------------+
//| 全ポジションのSL変更                                             |
//+------------------------------------------------------------------+
void ModifyAllPositionsSL()
{
    ReadPipsInput();
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double newSL;
                double currentPrice = position.PriceCurrent();
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    newSL = currentPrice - inputSLPips * point * 10;
                }
                else
                {
                    newSL = currentPrice + inputSLPips * point * 10;
                }
                
                if(trade.PositionModify(position.Ticket(), newSL, position.TakeProfit()))
                    modified++;
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションのSLを" + 
              DoubleToString(inputSLPips, 1) + "pipsに変更しました");
}

//+------------------------------------------------------------------+
//| 全ポジションのTP変更                                             |
//+------------------------------------------------------------------+
void ModifyAllPositionsTP()
{
    ReadPipsInput();
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double newTP;
                double openPrice = position.PriceOpen();
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    newTP = openPrice + inputTPPips * point * 10;
                }
                else
                {
                    newTP = openPrice - inputTPPips * point * 10;
                }
                
                if(trade.PositionModify(position.Ticket(), position.StopLoss(), newTP))
                    modified++;
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションのTPを" + 
              DoubleToString(inputTPPips, 1) + "pipsに変更しました");
}

//+------------------------------------------------------------------+
//| 矩形作成                                                         |
//+------------------------------------------------------------------+
void CreateRect(string name, int x, int y, int w, int h, color clr)
{
    ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, name, OBJPROP_CORNER, 0);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
}

//+------------------------------------------------------------------+
//| セクション作成                                                   |
//+------------------------------------------------------------------+
void CreateSection(int x, int y, int w, int h, string title, color bgColor)
{
    CreateRect("PC_Sec_" + title, x, y, w, h, bgColor);
    CreateLabel("PC_SecTitle_" + title, x + 15, y + 8, title, 11, clrWhite, "Arial Bold");
}

//+------------------------------------------------------------------+
//| ラベル作成                                                       |
//+------------------------------------------------------------------+
void CreateLabel(string name, int x, int y, string text, int size, color clr, 
                 string font = "Arial", ENUM_ANCHOR_POINT anchor = ANCHOR_LEFT_UPPER)
{
    ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetString(0, name, OBJPROP_FONT, font);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, size);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_ANCHOR, anchor);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
}

//+------------------------------------------------------------------+
//| ボタン作成                                                       |
//+------------------------------------------------------------------+
void CreateButton(string name, int x, int y, int w, int h, string text, color bgColor)
{
    ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 12);
    ObjectSetString(0, name, OBJPROP_FONT, "Arial Bold");
}

//+------------------------------------------------------------------+
//| 全体更新                                                         |
//+------------------------------------------------------------------+
void UpdateAll()
{
    UpdateAccountInfo();
    UpdatePositionInfo();
    UpdateDailyInfo();
    UpdateStatistics();
    UpdatePanelData();
}

//+------------------------------------------------------------------+
//| アカウント情報更新                                               |
//+------------------------------------------------------------------+
void UpdateAccountInfo()
{
    accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    
    currentPhase = current.phase;
    currentStage = current.stage;
    currentRiskPercent = current.riskPercent;
    
    // 動的リスク計算
    double calculatedRisk = accountBalance * (current.riskPercent / 100.0);
    currentMaxRisk = MathMin(current.maxRisk, calculatedRisk);
}

//+------------------------------------------------------------------+
//| ポジション情報更新                                               |
//+------------------------------------------------------------------+
void UpdatePositionInfo()
{
    totalProfit = 0;
    totalPips = 0;
    positionCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                positionCount++;
                totalProfit += position.Profit() + position.Swap() + position.Commission();
                
                // pips計算
                double openPrice = position.PriceOpen();
                double currentPrice = position.PriceCurrent();
                double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                    totalPips += (currentPrice - openPrice) / point / 10;
                else
                    totalPips += (openPrice - currentPrice) / point / 10;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| 日次情報更新                                                     |
//+------------------------------------------------------------------+
void UpdateDailyInfo()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime currentTimeStruct, lastTimeStruct;
    TimeToStruct(currentTime, currentTimeStruct);
    TimeToStruct(lastDayCheck, lastTimeStruct);
    
    // 日付が変わったらリセット
    if(lastDayCheck == 0 || currentTimeStruct.day_of_year != lastTimeStruct.day_of_year)
    {
        todayTradeCount = 0;
        todayProfit = 0;
        lastDayCheck = currentTime;
    }
    
    // 本日の取引を集計
    datetime todayStart = StringToTime(TimeToString(currentTime, TIME_DATE) + " 00:00");
    HistorySelect(todayStart, currentTime);
    
    int deals = HistoryDealsTotal();
    todayProfit = 0;
    todayTradeCount = 0;
    
    for(int i = 0; i < deals; i++)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
            if(profit != 0) // エントリーは除外
            {
                todayProfit += profit;
                todayTradeCount++;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| 統計情報更新                                                     |
//+------------------------------------------------------------------+
void UpdateStatistics()
{
    datetime currentTime = TimeCurrent();
    
    // 直近10トレードの統計
    datetime endTime = currentTime;
    datetime startTime = endTime - 30 * 24 * 60 * 60; // 30日前
    HistorySelect(startTime, endTime);
    
    int recentTrades = 0;
    int recentWins = 0;
    double totalRR = 0;
    
    int deals = HistoryDealsTotal();
    for(int i = deals - 1; i >= 0 && recentTrades < 10; i--)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
            if(profit != 0)
            {
                recentTrades++;
                if(profit > 0) recentWins++;
                // RR比の簡易計算（実際の損切りとの比率）
                if(profit > 0 && riskAmount > 0)
                    totalRR += profit / riskAmount;
            }
        }
    }
    
    stats.totalTrades = recentTrades;
    stats.winTrades = recentWins;
    stats.totalRR = totalRR;
    
    // 週次損益の計算（現在の曜日から週初めを計算）
    MqlDateTime timeStruct;
    TimeToStruct(currentTime, timeStruct);
    int daysSinceMonday = (timeStruct.day_of_week == 0) ? 6 : timeStruct.day_of_week - 1;
    datetime weekStart = currentTime - daysSinceMonday * 24 * 60 * 60;
    
    // 月次損益の計算（月初を取得）
    string monthStartStr = StringFormat("%04d.%02d.01", timeStruct.year, timeStruct.mon);
    datetime monthStart = StringToTime(monthStartStr);
    
    HistorySelect(weekStart, currentTime);
    stats.weeklyProfit = CalculatePeriodProfit();
    
    HistorySelect(monthStart, currentTime);
    stats.monthlyProfit = CalculatePeriodProfit();
}

//+------------------------------------------------------------------+
//| 期間損益計算                                                     |
//+------------------------------------------------------------------+
double CalculatePeriodProfit()
{
    double periodProfit = 0;
    int deals = HistoryDealsTotal();
    
    for(int i = 0; i < deals; i++)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            periodProfit += HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
        }
    }
    
    return periodProfit;
}

//+------------------------------------------------------------------+
//| パネルデータ更新                                                 |
//+------------------------------------------------------------------+
void UpdatePanelData()
{
    // アカウント情報
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    string badge = GetCurrentBadge();
    
    ObjectSetString(0, "PC_ValPhase", OBJPROP_TEXT, 
                    badge + " " + current.phaseTitle + "-" + current.stageName);
    ObjectSetString(0, "PC_ValBalance", OBJPROP_TEXT, IntegerToString((int)accountBalance) + "円");
    ObjectSetString(0, "PC_ValRisk", OBJPROP_TEXT, DoubleToString(currentRiskPercent, 1) + "%");
    ObjectSetString(0, "PC_ValMaxRisk", OBJPROP_TEXT, IntegerToString((int)currentMaxRisk) + "円");
    
    // 日次管理
    ObjectSetString(0, "PC_ValTodayTrades", OBJPROP_TEXT, 
                    IntegerToString(todayTradeCount) + "/" + IntegerToString(DailyTradeLimit));
    
    // 日次損益と増減率を計算
    double dailyChangePercent = 0;
    if(accountBalance - todayProfit > 0) {
        dailyChangePercent = (todayProfit / (accountBalance - todayProfit)) * 100;
    }
    string dailyPLText = IntegerToString((int)todayProfit) + "円";
    if(todayProfit != 0) {
        dailyPLText += " (" + (dailyChangePercent >= 0 ? "+" : "") + 
                        DoubleToString(dailyChangePercent, 2) + "%)";
    }
    
    ObjectSetString(0, "PC_ValTodayPL", OBJPROP_TEXT, dailyPLText);
    ObjectSetInteger(0, "PC_ValTodayPL", OBJPROP_COLOR, todayProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    // 取引状態
    string tradeStatus = "取引可能";
    color statusColor = C'76,175,80';
    if(todayTradeCount >= DailyTradeLimit) {
        tradeStatus = "上限到達";
        statusColor = C'244,67,54';
    }
    else if(todayProfit < -currentMaxRisk) {
        tradeStatus = "リスク制限";
        statusColor = C'255,152,0';
    }
    ObjectSetString(0, "PC_ValTradeStatus", OBJPROP_TEXT, tradeStatus);
    ObjectSetInteger(0, "PC_ValTradeStatus", OBJPROP_COLOR, statusColor);
    
    // ポジション情報
    ObjectSetString(0, "PC_ValPosCount", OBJPROP_TEXT, IntegerToString(positionCount));
    ObjectSetString(0, "PC_ValPL", OBJPROP_TEXT, IntegerToString((int)totalProfit) + "円");
    ObjectSetInteger(0, "PC_ValPL", OBJPROP_COLOR, totalProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    ObjectSetString(0, "PC_ValPips", OBJPROP_TEXT, DoubleToString(totalPips, 1));
    ObjectSetInteger(0, "PC_ValPips", OBJPROP_COLOR, totalPips >= 0 ? C'76,175,80' : C'244,67,54');
    
    ObjectSetString(0, "PC_ValAuto", OBJPROP_TEXT, EnableAutoClose ? "ON" : "OFF");
    ObjectSetInteger(0, "PC_ValAuto", OBJPROP_COLOR, EnableAutoClose ? C'76,175,80' : C'100,100,100');
    
    // 統計情報
    double winRate = stats.totalTrades > 0 ? (double)stats.winTrades / stats.totalTrades * 100 : 0;
    double avgRR = stats.winTrades > 0 ? stats.totalRR / stats.winTrades : 0;
    
    ObjectSetString(0, "PC_ValWinRate", OBJPROP_TEXT, DoubleToString(winRate, 1) + "%");
    ObjectSetString(0, "PC_ValAvgRR", OBJPROP_TEXT, DoubleToString(avgRR, 1));
    ObjectSetString(0, "PC_ValWeekly", OBJPROP_TEXT, IntegerToString((int)stats.weeklyProfit) + "円");
    ObjectSetInteger(0, "PC_ValWeekly", OBJPROP_COLOR, stats.weeklyProfit >= 0 ? C'76,175,80' : C'244,67,54');
    ObjectSetString(0, "PC_ValMonthly", OBJPROP_TEXT, IntegerToString((int)stats.monthlyProfit) + "円");
    ObjectSetInteger(0, "PC_ValMonthly", OBJPROP_COLOR, stats.monthlyProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    // LOT計算結果
    ObjectSetString(0, "PC_ValCalcRisk", OBJPROP_TEXT, 
        riskAmount > 0 ? IntegerToString((int)riskAmount) + "円" : "---");
    ObjectSetString(0, "PC_ValCalcLot", OBJPROP_TEXT, 
        calculatedLot > 0 ? DoubleToString(calculatedLot, 2) : "---");
    
    // 推奨リスク額の表示
    ObjectSetString(0, "PC_ValRecommend", OBJPROP_TEXT, 
        recommendedRiskAmount > 0 ? IntegerToString((int)recommendedRiskAmount) + "円 (" + 
        DoubleToString(currentRiskPercent / DailyTradeLimit, 2) + "%)" : "---");
    
    // ビジュアル要素の更新
    UpdateProgressBar("PC_PhaseProgress", GetPhaseProgress());
}

//+------------------------------------------------------------------+
//| 全ポジション決済                                                 |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 利益ポジションのみ決済                                           |
//+------------------------------------------------------------------+
void CloseProfitPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol && position.Profit() > 0)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " 利益ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 損失ポジションのみ決済                                           |
//+------------------------------------------------------------------+
void CloseLossPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol && position.Profit() < 0)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " 損失ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 建値ストップ移動                                                 |
//+------------------------------------------------------------------+
void MoveAllToBreakeven()
{
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * point;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double openPrice = position.PriceOpen();
                double currentPrice = position.PriceCurrent();
                double currentSL = position.StopLoss();
                
                // 20pips以上の利益で建値に移動
                double threshold = 20 * point * 10;
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    if(currentPrice - openPrice > threshold && currentSL < openPrice)
                    {
                        if(trade.PositionModify(position.Ticket(), openPrice + spread, position.TakeProfit()))
                            modified++;
                    }
                }
                else
                {
                    if(openPrice - currentPrice > threshold && (currentSL > openPrice || currentSL == 0))
                    {
                        if(trade.PositionModify(position.Ticket(), openPrice - spread, position.TakeProfit()))
                            modified++;
                    }
                }
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションを建値ストップに移動しました");
}

//+------------------------------------------------------------------+
//| 自動決済チェック                                                 |
//+------------------------------------------------------------------+
void CheckAutoClose()
{
    if(!EnableAutoClose) return;
    
    // 条件チェック
    bool shouldClose = false;
    string reason = "";
    
    if(totalPips >= AutoClosePips)
    {
        shouldClose = true;
        reason = "目標pips達成: " + DoubleToString(totalPips, 1) + "pips";
    }
    else if(totalProfit >= AutoCloseMoney)
    {
        shouldClose = true;
        reason = "目標金額達成: " + DoubleToString(totalProfit, 0) + "円";
    }
    
    // 自動決済実行
    if(shouldClose && positionCount > 0)
    {
        if(CloseOnlyProfit)
            CloseProfitPositions();
        else
            CloseAllPositions();
            
        Alert("自動決済実行: " + reason);
    }
}

//+------------------------------------------------------------------+
//| 日次リセットチェック                                             |
//+------------------------------------------------------------------+
void CheckDailyReset()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime currentTimeStruct, lastTimeStruct;
    TimeToStruct(currentTime, currentTimeStruct);
    TimeToStruct(lastDayCheck, lastTimeStruct);
    
    // 日付が変わったかチェック
    if(lastDayCheck != 0 && currentTimeStruct.day_of_year != lastTimeStruct.day_of_year)
    {
        todayTradeCount = 0;
        todayProfit = 0;
        lastDayCheck = currentTime;
        Alert("新しい取引日が始まりました");
    }
}

//+------------------------------------------------------------------+
//| 統計情報の保存                                                   |
//+------------------------------------------------------------------+
void SaveTradeStats()
{
    GlobalVariableSet("PC_TotalTrades", stats.totalTrades);
    GlobalVariableSet("PC_WinTrades", stats.winTrades);
    GlobalVariableSet("PC_TotalRR", stats.totalRR);
    GlobalVariableSet("PC_WeeklyProfit", stats.weeklyProfit);
    GlobalVariableSet("PC_MonthlyProfit", stats.monthlyProfit);
}

//+------------------------------------------------------------------+
//| 統計情報の読み込み                                               |
//+------------------------------------------------------------------+
void LoadTradeStats()
{
    if(GlobalVariableCheck("PC_TotalTrades"))
        stats.totalTrades = (int)GlobalVariableGet("PC_TotalTrades");
    if(GlobalVariableCheck("PC_WinTrades"))
        stats.winTrades = (int)GlobalVariableGet("PC_WinTrades");
    if(GlobalVariableCheck("PC_TotalRR"))
        stats.totalRR = GlobalVariableGet("PC_TotalRR");
    if(GlobalVariableCheck("PC_WeeklyProfit"))
        stats.weeklyProfit = GlobalVariableGet("PC_WeeklyProfit");
    if(GlobalVariableCheck("PC_MonthlyProfit"))
        stats.monthlyProfit = GlobalVariableGet("PC_MonthlyProfit");
}

//+------------------------------------------------------------------+
//| プログレスバー作成関数                                           |
//+------------------------------------------------------------------+
void CreateProgressBar(string name, int x, int y, int w, int h, double percent, 
                      color fillColor, color bgColor)
{
    // 背景
    string bgName = name + "_bg";
    CreateRect(bgName, x, y, w, h, bgColor);
    
    // 進捗バー
    string fillName = name + "_fill";
    int fillWidth = (int)(w * percent / 100);
    if(fillWidth > 0)
    {
        CreateRect(fillName, x, y, fillWidth, h, fillColor);
    }
    
    // パーセント表示
    string textName = name + "_text";
    CreateLabel(textName, x + w/2, y + h/2 - 7, 
                DoubleToString(percent, 1) + "%", 10, clrWhite, "Arial Bold", ANCHOR_CENTER);
}

//+------------------------------------------------------------------+
//| フェーズ進捗率計算                                               |
//+------------------------------------------------------------------+
double GetPhaseProgress()
{
    return GetSubPhaseProgress();
}

//+------------------------------------------------------------------+
//| リスク使用率計算                                                 |
//+------------------------------------------------------------------+
double GetRiskUsageRate()
{
    if(currentMaxRisk == 0) return 0;
    
    // 現在のポジションの合計リスクを計算
    double totalRisk = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double positionRisk = MathAbs(position.PriceOpen() - position.StopLoss()) * 
                                    position.Volume() * 
                                    SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE) * 10;
                totalRisk += positionRisk;
            }
        }
    }
    
    return (totalRisk / currentMaxRisk) * 100;
}

//+------------------------------------------------------------------+
//| プログレスバー更新                                               |
//+------------------------------------------------------------------+
void UpdateProgressBar(string name, double percent)
{
    // fillWidthが0の時の処理を追加
    string fillName = name + "_fill";
    string bgName = name + "_bg";
    
    if(ObjectFind(0, bgName) >= 0)
    {
        int bgWidth = (int)ObjectGetInteger(0, bgName, OBJPROP_XSIZE);
        int fillWidth = (int)(bgWidth * percent / 100);
        
        // fillが既に存在する場合は更新、存在しない場合は作成
        if(ObjectFind(0, fillName) >= 0)
        {
            if(fillWidth > 0)
            {
                ObjectSetInteger(0, fillName, OBJPROP_XSIZE, fillWidth);
            }
            else
            {
                ObjectDelete(0, fillName);  // 0%の場合は削除
            }
        }
        else if(fillWidth > 0)
        {
            // fillを新規作成
            int bgX = (int)ObjectGetInteger(0, bgName, OBJPROP_XDISTANCE);
            int bgY = (int)ObjectGetInteger(0, bgName, OBJPROP_YDISTANCE);
            int bgH = (int)ObjectGetInteger(0, bgName, OBJPROP_YSIZE);
            CreateRect(fillName, bgX, bgY, fillWidth, bgH, C'52,152,219');
        }
    }
    
    // テキスト更新
    string textName = name + "_text";
    if(ObjectFind(0, textName) >= 0)
    {
        ObjectSetString(0, textName, OBJPROP_TEXT, DoubleToString(percent, 1) + "%");
    }
}

//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| 現在のフェーズ情報を取得                                         |
//+------------------------------------------------------------------+
PhaseInfo GetCurrentPhaseInfo(double balance)
{
    for(int i = 0; i < 15; i++)
    {
        if(balance >= phaseData[i].startBalance && balance < phaseData[i].endBalance)
        {
            return phaseData[i];
        }
    }
    
    // 最終段階を超えた場合
    PhaseInfo finalPhase = phaseData[14];
    finalPhase.stageName = "レジェンド";
    return finalPhase;
}

//+------------------------------------------------------------------+
//| サブフェーズの進捗率を取得                                       |
//+------------------------------------------------------------------+
double GetSubPhaseProgress()
{
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    
    if(accountBalance >= current.endBalance)
        return 100.0;
        
    double progress = (accountBalance - current.startBalance) / 
                     (current.endBalance - current.startBalance) * 100.0;
    
    return MathMax(0, MathMin(100, progress));
}

//+------------------------------------------------------------------+
//| 全体の進捗率を取得                                               |
//+------------------------------------------------------------------+
double GetOverallProgress()
{
    double maxBalance = 3000000; // 最終目標
    double progress = (accountBalance - 5000) / (maxBalance - 5000) * 100.0;
    
    return MathMax(0, MathMin(100, progress));
}

//+------------------------------------------------------------------+
//| 次のマイルストーンまでの距離                                     |
//+------------------------------------------------------------------+
double GetNextMilestoneDistance()
{
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    return current.endBalance - accountBalance;
}

//+------------------------------------------------------------------+
//| 達成ポイントの計算                                               |
//+------------------------------------------------------------------+
int GetAchievementPoints()
{
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    
    // フェーズ × ステージで基本ポイント
    int basePoints = current.phase * 100 + (current.stage + 1) * 10;
    
    // 進捗率ボーナス
    double progress = GetSubPhaseProgress();
    int progressBonus = (int)(progress / 10) * 5; // 10%ごとに5ポイント
    
    return basePoints + progressBonus;
}

//+------------------------------------------------------------------+
//| 現在のバッジを取得                                               |
//+------------------------------------------------------------------+
string GetCurrentBadge()
{
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    
    int index = (current.phase - 1) * 3 + current.stage;
    if(index < 15)
        return badges[index];
    
    return "MAX";
}

//+------------------------------------------------------------------+
//| レベルアップチェック                                             |
//+------------------------------------------------------------------+
bool CheckLevelUp(double oldBalance, double newBalance)
{
    PhaseInfo oldPhase = GetCurrentPhaseInfo(oldBalance);
    PhaseInfo newPhase = GetCurrentPhaseInfo(newBalance);
    
    // サブフェーズが変わったかチェック
    if(oldPhase.phase != newPhase.phase || oldPhase.stage != newPhase.stage)
    {
        string message = StringFormat(
            "🎉 レベルアップ！\n%s %s 達成！\n獲得バッジ: %s\n進捗: %.1f%% → %.1f%%",
            newPhase.phaseTitle,
            newPhase.stageName,
            GetCurrentBadge(),
            (oldBalance - oldPhase.startBalance) / (oldPhase.endBalance - oldPhase.startBalance) * 100,
            GetSubPhaseProgress()
        );
        
        Alert(message);
        Print(message);
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| フェーズ詳細情報取得                                             |
//+------------------------------------------------------------------+
string GetPhaseDetails()
{
    PhaseInfo current = GetCurrentPhaseInfo(accountBalance);
    double subProgress = GetSubPhaseProgress();
    double overallProgress = GetOverallProgress();
    int points = GetAchievementPoints();
    
    string details = StringFormat(
        "=== フェーズ詳細 ===\n"
        "%s %s - %s\n"
        "サブ進捗: %.1f%% (¥%.0f/¥%.0f)\n"
        "全体進捗: %.1f%% (最終目標: ¥3,000,000)\n"
        "獲得ポイント: %d pt\n"
        "次のマイルストーン: ¥%.0f (残り¥%.0f)\n"
        "現在リスク設定: %.1f%% (上限¥%.0f)",
        GetCurrentBadge(),
        current.phaseTitle,
        current.stageName,
        subProgress,
        accountBalance,
        current.endBalance,
        overallProgress,
        points,
        current.endBalance,
        GetNextMilestoneDistance(),
        currentRiskPercent,
        currentMaxRisk
    );
    
    return details;
}

