//+------------------------------------------------------------------+
//|                                      moneyManagement_v7.mq5      |
//|                                  Copyright 2024, TraderAssistant |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, TraderAssistant"
#property version   "7.00"
#property description "TraderAssistant - Pips Based Version"

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>

//--- 入力パラメータ
input group "=== 基本設定 ==="
input double   DefaultRRRatio = 5.0;        // デフォルトRR比
input bool     EnableSplitEntry = true;     // 分割エントリー
input int      SplitCount = 2;              // 分割数
input int      DailyTradeLimit = 4;         // 日次トレード上限

input group "=== 自動決済設定 ==="
input bool     EnableAutoClose = true;      // 自動決済を有効化
input double   AutoClosePips = 200.0;       // 合計獲得pips（自動決済）
input double   AutoCloseMoney = 3000.0;     // 合計獲得金額（自動決済）
input bool     CloseOnlyProfit = true;      // 利益ポジションのみ決済

input group "=== パネル設定 ==="
input int      PanelPosX = 20;             // パネルX位置
input int      PanelPosY = 50;             // パネルY位置

//--- グローバル変数
CTrade trade;
CPositionInfo position;
CDealInfo deal;
double accountBalance, currentRiskPercent, currentMaxRisk;
int currentPhase;

// LOT計算用変数
double inputSLPips = 20.0;      // デフォルトSL pips
double inputTPPips = 100.0;     // デフォルトTP pips
double inputRiskAmount = 0.0;   // 手動入力リスク額
double inputRiskPercent = 0.0;  // 手動入力リスク率
double calculatedLot = 0.0;
double riskAmount = 0.0;
double recommendedRiskAmount = 0.0; // 推奨リスク額

// ポジション管理
double totalProfit = 0;
double totalPips = 0;
int positionCount = 0;

// 日次管理
int todayTradeCount = 0;
double todayProfit = 0;
datetime lastDayCheck = 0;

// 統計管理
struct TradeStats {
    int totalTrades;
    int winTrades;
    double totalRR;
    double weeklyProfit;
    double monthlyProfit;
};
TradeStats stats;

// エディットボックス名
string slPipsEditName = "PC_EditSLPips";
string tpPipsEditName = "PC_EditTPPips";
string riskAmountEditName = "PC_EditRiskAmount";
string riskPercentEditName = "PC_EditRiskPercent";

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    trade.SetExpertMagicNumber(123456);
    CreateEnhancedPanel();
    LoadTradeStats();
    UpdateAll();
    EventSetTimer(1);
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    EventKillTimer();
    ObjectsDeleteAll(0, "PC_");
    SaveTradeStats();
}

//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
{
    UpdateAll();
    CheckAutoClose();
    CheckDailyReset();
}

//+------------------------------------------------------------------+
//| Trade function                                                   |
//+------------------------------------------------------------------+
void OnTrade()
{
    UpdatePositionInfo();
}

//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    // ボタンクリックイベント
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        // LOT計算関連
        if(sparam == "PC_BtnCalcLot") { CalculateLotFromPips(); UpdateAll(); }
        else if(sparam == "PC_BtnBuyMarket") ExecuteMarketOrder(true);
        else if(sparam == "PC_BtnSellMarket") ExecuteMarketOrder(false);
        
        // ポジション管理ボタン
        else if(sparam == "PC_BtnCloseAll") CloseAllPositions();
        else if(sparam == "PC_BtnCloseProfit") CloseProfitPositions();
        else if(sparam == "PC_BtnCloseLoss") CloseLossPositions();
        else if(sparam == "PC_BtnBreakeven") MoveAllToBreakeven();
        else if(sparam == "PC_BtnModifySL") ModifyAllPositionsSL();
        else if(sparam == "PC_BtnModifyTP") ModifyAllPositionsTP();
    }
    
    // エディットボックスの値変更
    if(id == CHARTEVENT_OBJECT_ENDEDIT)
    {
        if(sparam == slPipsEditName || sparam == tpPipsEditName || 
           sparam == riskAmountEditName || sparam == riskPercentEditName)
        {
            ReadPipsInput();
        }
    }
}

//+------------------------------------------------------------------+
//| 拡張版パネル作成                                                 |
//+------------------------------------------------------------------+
void CreateEnhancedPanel()
{
    int x = PanelPosX;
    int y = PanelPosY;
    int width = 800;
    int lineHeight = 45;  
    int sectionGap = 25;
    int padding = 20;
    
    // 色定義
    color bgColor = C'25,27,30';
    color sectionBg = C'35,37,40';
    color headerBg = C'45,55,72';
    color textColor = C'220,220,220';
    color labelColor = C'160,160,160';
    color greenColor = C'76,175,80';
    color redColor = C'244,67,54';
    color blueColor = C'33,150,243';
    color orangeColor = C'255,152,0';
    
    // メイン背景
    CreateRect("PC_MainBg", x, y, width, 1050, bgColor);
    
    // ヘッダー
    CreateRect("PC_Header", x, y, width, 50, headerBg);
    CreateLabel("PC_Title", x + width/2, y + 15, "MT5 Trade Management System - Pips Version", 
                16, clrWhite, "Arial Bold", ANCHOR_CENTER);
    
    y += 65;
    
    // === アカウント情報セクション ===
    CreateSection(x, y, width, 120, "アカウント情報", sectionBg);
    
    // Phase & Balance - 1行目
    CreateLabel("PC_LblPhase", x + padding, y + 45, "Phase", 12, labelColor);
    CreateLabel("PC_ValPhase", x + 120, y + 45, "1", 12, greenColor, "Arial Bold");
    
    CreateLabel("PC_LblBalance", x + 200, y + 45, "残高", 12, labelColor);
    CreateLabel("PC_ValBalance", x + 380, y + 45, "0円", 12, textColor, "Arial Bold");
    
    // Risk & Max Risk - 2行目
    CreateLabel("PC_LblRisk", x + padding, y + 85, "Risk", 12, labelColor);
    CreateLabel("PC_ValRisk", x + 100, y + 85, "0%", 12, redColor, "Arial Bold");
    
    CreateLabel("PC_LblMaxRisk", x + 200, y + 85, "Max Risk", 12, labelColor);
    CreateLabel("PC_ValMaxRisk", x + 400, y + 85, "0円", 12, redColor, "Arial Bold");
    
    // フェーズ進捗バー
    CreateProgressBar("PC_PhaseProgress", x + 600, y + 45, 150, 20, 
                      GetPhaseProgress(), C'52,152,219', C'60,60,60');
    CreateLabel("PC_PhaseProgressLabel", x + 600, y + 5, "フェーズ進捗", 10, labelColor);
    
    // リスク使用率ゲージ
    CreateProgressBar("PC_RiskGauge", x + 600, y + 100, 150, 20, 
                      GetRiskUsageRate(), C'244,67,54', C'60,60,60');
    CreateLabel("PC_RiskGaugeLabel", x + 600, y + 65, "リスク使用率", 10, labelColor);
    
    y += 130;
    
    // === 日次管理セクション ===
    CreateSection(x, y, width, 120, "日次管理", sectionBg);
    
    // Today's Trade Count & Daily P/L - 1行目
    CreateLabel("PC_LblTodayTrades", x + padding, y + 45, "本日取引", 12, labelColor);
    CreateLabel("PC_ValTodayTrades", x + 200, y + 45, "0/3", 12, blueColor, "Arial Bold");
    
    CreateLabel("PC_LblTodayPL", x + 280, y + 45, "日次損益", 12, labelColor);
    CreateLabel("PC_ValTodayPL", x + 480, y + 45, "0円", 12, textColor, "Arial Bold");
    
    // Trade Status - 2行目
    CreateLabel("PC_LblTradeStatus", x + padding, y + 85, "取引状態", 12, labelColor);
    CreateLabel("PC_ValTradeStatus", x + 160, y + 85, "取引可能", 12, greenColor, "Arial Bold");
    
    y += 130;
    
    // === ポジション状況セクション ===
    CreateSection(x, y, width, 120, "ポジション状況", sectionBg);
    
    // Position Count & P/L - 1行目
    CreateLabel("PC_LblPosCount", x + padding, y + 45, "保有数", 12, labelColor);
    CreateLabel("PC_ValPosCount", x + 140, y + 45, "0", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblPL", x + 200, y + 45, "損益", 12, labelColor);
    CreateLabel("PC_ValPL", x + 280, y + 45, "0円", 12, textColor, "Arial Bold");
    
    // Pips & Auto Close - 2行目
    CreateLabel("PC_LblPips", x + padding, y + 85, "Pips", 12, labelColor);
    CreateLabel("PC_ValPips", x + 100, y + 85, "0.0", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblAuto", x + 200, y + 85, "自動決済", 12, labelColor);
    CreateLabel("PC_ValAuto", x + 380, y + 85, "OFF", 12, greenColor, "Arial Bold");
    
    y += 130;
    
    // === 統計情報セクション ===
    CreateSection(x, y, width, 120, "統計情報", sectionBg);
    
    // Win Rate & Average RR - 1行目
    CreateLabel("PC_LblWinRate", x + padding, y + 45, "直近10勝率", 12, labelColor);
    CreateLabel("PC_ValWinRate", x + 210, y + 45, "0%", 12, blueColor, "Arial Bold");
    
    CreateLabel("PC_LblAvgRR", x + 330, y + 45, "平均RR比", 12, labelColor);
    CreateLabel("PC_ValAvgRR", x + 550, y + 45, "0.0", 12, blueColor, "Arial Bold");
    
    // Weekly & Monthly - 2行目
    CreateLabel("PC_LblWeekly", x + padding, y + 75, "週次損益", 12, labelColor);
    CreateLabel("PC_ValWeekly", x + 180, y + 85, "0円", 12, textColor, "Arial Bold");
    
    CreateLabel("PC_LblMonthly", x + 330, y + 85, "月次損益", 12, labelColor);
    CreateLabel("PC_ValMonthly", x + 550, y + 85, "0円", 12, textColor, "Arial Bold");
    
    y += 130;
    
    // === LOT計算セクション ===
    CreateSection(x, y, width, 240, "LOT計算", sectionBg);
    
    // SL pips入力
    CreateLabel("PC_LblSLPips", x + padding, y + 40, "S/L pips", 13, labelColor);
    CreateEditBox(slPipsEditName, x + 120, y + 35, 100, 30, 
                  DoubleToString(inputSLPips, 1), 14, textColor, sectionBg);
    
    // TP pips入力
    CreateLabel("PC_LblTPPips", x + 280, y + 40, "T/P pips", 13, labelColor);
    CreateEditBox(tpPipsEditName, x + 380, y + 35, 100, 30, 
                  DoubleToString(inputTPPips, 1), 14, textColor, sectionBg);
    
    // リスク額入力
    CreateLabel("PC_LblRiskAmount", x + padding, y + 85, "損失額", 13, labelColor);
    CreateEditBox(riskAmountEditName, x + 120, y + 80, 100, 30, 
                  "0", 14, textColor, sectionBg);
    CreateLabel("PC_LblRiskAmountYen", x + 225, y + 85, "円", 13, labelColor);
    
    // リスク率入力
    CreateLabel("PC_LblRiskPercent", x + 280, y + 85, "損失率", 13, labelColor);
    CreateEditBox(riskPercentEditName, x + 380, y + 80, 100, 30, 
                  "0", 14, textColor, sectionBg);
    CreateLabel("PC_LblRiskPercentMark", x + 485, y + 85, "%", 13, labelColor);
    
    // 推奨値表示
    CreateLabel("PC_LblRecommend", x + padding, y + 125, "推奨リスク", 13, labelColor);
    CreateLabel("PC_ValRecommend", x + 160, y + 125, "---", 12, C'100,150,250', "Arial");
    
    // 計算結果表示
    CreateLabel("PC_LblCalcRisk", x + padding, y + 155, "使用リスク額", 13, labelColor);
    CreateLabel("PC_ValCalcRisk", x + 160, y + 155, "---", 13, redColor, "Arial Bold");
    
    CreateLabel("PC_LblCalcLot", x + 280, y + 155, "推奨LOT", 13, labelColor);
    CreateLabel("PC_ValCalcLot", x + 420, y + 155, "---", 15, greenColor, "Arial Black");
    
    // LOT計算ボタン
    CreateButton("PC_BtnCalcLot", x + padding, y + 185, 200, 40, "LOT計算", greenColor);
    
    // マーケット注文ボタン
    CreateButton("PC_BtnBuyMarket", x + 230, y + 185, 180, 40, "BUY 成行", blueColor);
    CreateButton("PC_BtnSellMarket", x + 420, y + 185, 180, 40, "SELL 成行", redColor);
    
    // 分割エントリー表示
    CreateLabel("PC_LblSplitInfo", x + padding, y + 235, 
                "分割エントリー: " + (EnableSplitEntry ? "ON (" + IntegerToString(SplitCount) + "分割)" : "OFF"), 
                11, labelColor);
    
    y += 250;
    
    // === ポジション管理セクション ===
    CreateSection(x, y, width, 180, "ポジション管理", sectionBg);
    
    // SL/TP一括変更
    CreateLabel("PC_LblModify", x + padding, y + 40, "既存ポジションのSL/TP一括変更", 12, labelColor);
    CreateButton("PC_BtnModifySL", x + padding, y + 65, 295, 35, "全ポジSL変更", orangeColor);
    CreateButton("PC_BtnModifyTP", x + 335, y + 65, 295, 35, "全ポジTP変更", orangeColor);
    
    // 決済ボタン
    CreateButton("PC_BtnCloseAll", x + padding, y + 110, 295, 35, "全ポジション決済", redColor);
    CreateButton("PC_BtnBreakeven", x + 335, y + 110, 295, 35, "建値ストップ", blueColor);
    
    CreateButton("PC_BtnCloseProfit", x + padding, y + 150, 295, 35, "利益のみ決済", greenColor);
    CreateButton("PC_BtnCloseLoss", x + 335, y + 150, 295, 35, "損失のみ決済", orangeColor);
    
    y += 190;
    
    // === 操作方法 ===
    CreateSection(x, y, width, 80, "操作方法", sectionBg);
    
    CreateLabel("PC_Help1", x + padding, y + 35, 
                "• SL/TP pipsを入力してLOT計算 → 成行注文", 
                11, labelColor);
    CreateLabel("PC_Help2", x + padding, y + 55, 
                "• 自動決済: " + DoubleToString(AutoClosePips, 1) + "pips / " + 
                DoubleToString(AutoCloseMoney, 0) + "円", 
                11, labelColor);
}

//+------------------------------------------------------------------+
//| エディットボックス作成                                           |
//+------------------------------------------------------------------+
void CreateEditBox(string name, int x, int y, int w, int h, string text, 
                   int fontSize, color textColor, color bgColor)
{
    ObjectCreate(0, name, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
    ObjectSetInteger(0, name, OBJPROP_COLOR, textColor);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, C'100,100,100');
    ObjectSetInteger(0, name, OBJPROP_ALIGN, ALIGN_CENTER);
}

//+------------------------------------------------------------------+
//| Pips入力値読み取り                                               |
//+------------------------------------------------------------------+
void ReadPipsInput()
{
    string slText = ObjectGetString(0, slPipsEditName, OBJPROP_TEXT);
    string tpText = ObjectGetString(0, tpPipsEditName, OBJPROP_TEXT);
    string riskAmountText = ObjectGetString(0, riskAmountEditName, OBJPROP_TEXT);
    string riskPercentText = ObjectGetString(0, riskPercentEditName, OBJPROP_TEXT);
    
    inputSLPips = StringToDouble(slText);
    inputTPPips = StringToDouble(tpText);
    inputRiskAmount = StringToDouble(riskAmountText);
    inputRiskPercent = StringToDouble(riskPercentText);
    
    // 値の検証
    if(inputSLPips <= 0) inputSLPips = 20.0;
    if(inputTPPips <= 0) inputTPPips = 100.0;
    if(inputRiskAmount < 0) inputRiskAmount = 0;
    if(inputRiskPercent < 0) inputRiskPercent = 0;
}

//+------------------------------------------------------------------+
//| Pipsベースでのロット計算                                         |
//+------------------------------------------------------------------+
void CalculateLotFromPips()
{
    ReadPipsInput();
    
    // 推奨リスク額の計算（表示用）
    recommendedRiskAmount = MathMin(accountBalance * currentRiskPercent / 100, currentMaxRisk);
    recommendedRiskAmount = recommendedRiskAmount / DailyTradeLimit;
    
    // 前日マイナス時の推奨値調整
    if(todayProfit < 0) {
        recommendedRiskAmount = recommendedRiskAmount / 2;
    }
    
    // 実際に使用するリスク額の決定
    if(inputRiskAmount > 0) {
        // 手動入力額を優先
        riskAmount = inputRiskAmount;
    }
    else if(inputRiskPercent > 0) {
        // 手動入力率から計算
        riskAmount = accountBalance * inputRiskPercent / 100;
    }
    else {
        // どちらも入力されていない場合は推奨値を使用
        riskAmount = recommendedRiskAmount;
        Alert("リスク額が入力されていないため、推奨値を使用します: " + 
              IntegerToString((int)riskAmount) + "円");
    }
    
    // ロット計算
    double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    double onePipValue = tickValue * 10;
    
    calculatedLot = riskAmount / (inputSLPips * onePipValue);
    
    // ロット調整
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
    calculatedLot = MathFloor(calculatedLot / lotStep) * lotStep;
    calculatedLot = MathMax(minLot, MathMin(maxLot, calculatedLot));
    
    Comment("LOT計算完了: " + DoubleToString(calculatedLot, 2) + 
            " (SL: " + DoubleToString(inputSLPips, 1) + "pips, " +
            "TP: " + DoubleToString(inputTPPips, 1) + "pips, " +
            "リスク: " + IntegerToString((int)riskAmount) + "円)");
}

//+------------------------------------------------------------------+
//| 成行注文実行                                                     |
//+------------------------------------------------------------------+
void ExecuteMarketOrder(bool isBuy)
{
    // 日次上限チェック
    if(todayTradeCount >= DailyTradeLimit) {
        Alert("日次トレード上限に達しています");
        return;
    }
    
    if(calculatedLot == 0) {
        Alert("先にLOT計算してください");
        return;
    }
    
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    double sl, tp;
    
    if(EnableSplitEntry && SplitCount > 1)
    {
        double lotPerTrade = calculatedLot / SplitCount;
        for(int i = 0; i < SplitCount; i++)
        {
            if(isBuy)
            {
                sl = ask - inputSLPips * point * 10;
                tp = ask + inputTPPips * point * 10;
                trade.Buy(lotPerTrade, _Symbol, 0, sl, tp, 
                         "Split " + IntegerToString(i+1) + "/" + IntegerToString(SplitCount));
            }
            else
            {
                sl = bid + inputSLPips * point * 10;
                tp = bid - inputTPPips * point * 10;
                trade.Sell(lotPerTrade, _Symbol, 0, sl, tp,
                          "Split " + IntegerToString(i+1) + "/" + IntegerToString(SplitCount));
            }
        }
    }
    else
    {
        if(isBuy)
        {
            sl = ask - inputSLPips * point * 10;
            tp = ask + inputTPPips * point * 10;
            trade.Buy(calculatedLot, _Symbol, 0, sl, tp);
        }
        else
        {
            sl = bid + inputSLPips * point * 10;
            tp = bid - inputTPPips * point * 10;
            trade.Sell(calculatedLot, _Symbol, 0, sl, tp);
        }
    }
    
    todayTradeCount++;
    calculatedLot = 0; // リセット
}

//+------------------------------------------------------------------+
//| 全ポジションのSL変更                                             |
//+------------------------------------------------------------------+
void ModifyAllPositionsSL()
{
    ReadPipsInput();
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double newSL;
                double currentPrice = position.PriceCurrent();
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    newSL = currentPrice - inputSLPips * point * 10;
                }
                else
                {
                    newSL = currentPrice + inputSLPips * point * 10;
                }
                
                if(trade.PositionModify(position.Ticket(), newSL, position.TakeProfit()))
                    modified++;
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションのSLを" + 
              DoubleToString(inputSLPips, 1) + "pipsに変更しました");
}

//+------------------------------------------------------------------+
//| 全ポジションのTP変更                                             |
//+------------------------------------------------------------------+
void ModifyAllPositionsTP()
{
    ReadPipsInput();
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double newTP;
                double openPrice = position.PriceOpen();
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    newTP = openPrice + inputTPPips * point * 10;
                }
                else
                {
                    newTP = openPrice - inputTPPips * point * 10;
                }
                
                if(trade.PositionModify(position.Ticket(), position.StopLoss(), newTP))
                    modified++;
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションのTPを" + 
              DoubleToString(inputTPPips, 1) + "pipsに変更しました");
}

//+------------------------------------------------------------------+
//| 矩形作成                                                         |
//+------------------------------------------------------------------+
void CreateRect(string name, int x, int y, int w, int h, color clr)
{
    ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, name, OBJPROP_CORNER, 0);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
}

//+------------------------------------------------------------------+
//| セクション作成                                                   |
//+------------------------------------------------------------------+
void CreateSection(int x, int y, int w, int h, string title, color bgColor)
{
    CreateRect("PC_Sec_" + title, x, y, w, h, bgColor);
    CreateLabel("PC_SecTitle_" + title, x + 15, y + 8, title, 11, clrWhite, "Arial Bold");
}

//+------------------------------------------------------------------+
//| ラベル作成                                                       |
//+------------------------------------------------------------------+
void CreateLabel(string name, int x, int y, string text, int size, color clr, 
                 string font = "Arial", ENUM_ANCHOR_POINT anchor = ANCHOR_LEFT_UPPER)
{
    ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetString(0, name, OBJPROP_FONT, font);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, size);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_ANCHOR, anchor);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
}

//+------------------------------------------------------------------+
//| ボタン作成                                                       |
//+------------------------------------------------------------------+
void CreateButton(string name, int x, int y, int w, int h, string text, color bgColor)
{
    ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 12);
    ObjectSetString(0, name, OBJPROP_FONT, "Arial Bold");
}

//+------------------------------------------------------------------+
//| 全体更新                                                         |
//+------------------------------------------------------------------+
void UpdateAll()
{
    UpdateAccountInfo();
    UpdatePositionInfo();
    UpdateDailyInfo();
    UpdateStatistics();
    UpdatePanelData();
}

//+------------------------------------------------------------------+
//| アカウント情報更新                                               |
//+------------------------------------------------------------------+
void UpdateAccountInfo()
{
    accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    
    if(accountBalance < 20000) {
        currentPhase = 1;
        currentRiskPercent = 7.0;
        currentMaxRisk = MathMin(400, accountBalance * 0.07);
    }
    else if(accountBalance < 50000) {
        currentPhase = 2;
        currentRiskPercent = 6.0;
        currentMaxRisk = MathMin(800, accountBalance * 0.06);
    }
    else if(accountBalance < 150000) {
        currentPhase = 3;
        currentRiskPercent = 5.0;
        currentMaxRisk = MathMin(1500, accountBalance * 0.05);
    }
    else if(accountBalance < 500000) {
        currentPhase = 4;
        currentRiskPercent = 4.0;
        currentMaxRisk = MathMin(3000, accountBalance * 0.04);
    }
    else {
        currentPhase = 5;
        currentRiskPercent = 3.0;
        currentMaxRisk = MathMin(5000, accountBalance * 0.03);
    }
}

//+------------------------------------------------------------------+
//| ポジション情報更新                                               |
//+------------------------------------------------------------------+
void UpdatePositionInfo()
{
    totalProfit = 0;
    totalPips = 0;
    positionCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                positionCount++;
                totalProfit += position.Profit() + position.Swap() + position.Commission();
                
                // pips計算
                double openPrice = position.PriceOpen();
                double currentPrice = position.PriceCurrent();
                double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                    totalPips += (currentPrice - openPrice) / point / 10;
                else
                    totalPips += (openPrice - currentPrice) / point / 10;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| 日次情報更新                                                     |
//+------------------------------------------------------------------+
void UpdateDailyInfo()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime currentTimeStruct, lastTimeStruct;
    TimeToStruct(currentTime, currentTimeStruct);
    TimeToStruct(lastDayCheck, lastTimeStruct);
    
    // 日付が変わったらリセット
    if(lastDayCheck == 0 || currentTimeStruct.day_of_year != lastTimeStruct.day_of_year)
    {
        todayTradeCount = 0;
        todayProfit = 0;
        lastDayCheck = currentTime;
    }
    
    // 本日の取引を集計
    datetime todayStart = StringToTime(TimeToString(currentTime, TIME_DATE) + " 00:00");
    HistorySelect(todayStart, currentTime);
    
    int deals = HistoryDealsTotal();
    todayProfit = 0;
    todayTradeCount = 0;
    
    for(int i = 0; i < deals; i++)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
            if(profit != 0) // エントリーは除外
            {
                todayProfit += profit;
                todayTradeCount++;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| 統計情報更新                                                     |
//+------------------------------------------------------------------+
void UpdateStatistics()
{
    datetime currentTime = TimeCurrent();
    
    // 直近10トレードの統計
    datetime endTime = currentTime;
    datetime startTime = endTime - 30 * 24 * 60 * 60; // 30日前
    HistorySelect(startTime, endTime);
    
    int recentTrades = 0;
    int recentWins = 0;
    double totalRR = 0;
    
    int deals = HistoryDealsTotal();
    for(int i = deals - 1; i >= 0 && recentTrades < 10; i--)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
            if(profit != 0)
            {
                recentTrades++;
                if(profit > 0) recentWins++;
                // RR比の簡易計算（実際の損切りとの比率）
                if(profit > 0 && riskAmount > 0)
                    totalRR += profit / riskAmount;
            }
        }
    }
    
    stats.totalTrades = recentTrades;
    stats.winTrades = recentWins;
    stats.totalRR = totalRR;
    
    // 週次損益の計算（現在の曜日から週初めを計算）
    MqlDateTime timeStruct;
    TimeToStruct(currentTime, timeStruct);
    int daysSinceMonday = (timeStruct.day_of_week == 0) ? 6 : timeStruct.day_of_week - 1;
    datetime weekStart = currentTime - daysSinceMonday * 24 * 60 * 60;
    
    // 月次損益の計算（月初を取得）
    string monthStartStr = StringFormat("%04d.%02d.01", timeStruct.year, timeStruct.mon);
    datetime monthStart = StringToTime(monthStartStr);
    
    HistorySelect(weekStart, currentTime);
    stats.weeklyProfit = CalculatePeriodProfit();
    
    HistorySelect(monthStart, currentTime);
    stats.monthlyProfit = CalculatePeriodProfit();
}

//+------------------------------------------------------------------+
//| 期間損益計算                                                     |
//+------------------------------------------------------------------+
double CalculatePeriodProfit()
{
    double periodProfit = 0;
    int deals = HistoryDealsTotal();
    
    for(int i = 0; i < deals; i++)
    {
        ulong dealTicket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
        {
            periodProfit += HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
        }
    }
    
    return periodProfit;
}

//+------------------------------------------------------------------+
//| パネルデータ更新                                                 |
//+------------------------------------------------------------------+
void UpdatePanelData()
{
    // アカウント情報
    ObjectSetString(0, "PC_ValPhase", OBJPROP_TEXT, IntegerToString(currentPhase));
    ObjectSetString(0, "PC_ValBalance", OBJPROP_TEXT, IntegerToString((int)accountBalance) + "円");
    ObjectSetString(0, "PC_ValRisk", OBJPROP_TEXT, DoubleToString(currentRiskPercent, 1) + "%");
    ObjectSetString(0, "PC_ValMaxRisk", OBJPROP_TEXT, IntegerToString((int)currentMaxRisk) + "円");
    
    // 日次管理
    ObjectSetString(0, "PC_ValTodayTrades", OBJPROP_TEXT, 
                    IntegerToString(todayTradeCount) + "/" + IntegerToString(DailyTradeLimit));
    
    // 日次損益と増減率を計算
    double dailyChangePercent = 0;
    if(accountBalance - todayProfit > 0) {
        dailyChangePercent = (todayProfit / (accountBalance - todayProfit)) * 100;
    }
    string dailyPLText = IntegerToString((int)todayProfit) + "円";
    if(todayProfit != 0) {
        dailyPLText += " (" + (dailyChangePercent >= 0 ? "+" : "") + 
                        DoubleToString(dailyChangePercent, 2) + "%)";
    }
    
    ObjectSetString(0, "PC_ValTodayPL", OBJPROP_TEXT, dailyPLText);
    ObjectSetInteger(0, "PC_ValTodayPL", OBJPROP_COLOR, todayProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    // 取引状態
    string tradeStatus = "取引可能";
    color statusColor = C'76,175,80';
    if(todayTradeCount >= DailyTradeLimit) {
        tradeStatus = "上限到達";
        statusColor = C'244,67,54';
    }
    else if(todayProfit < -currentMaxRisk) {
        tradeStatus = "リスク制限";
        statusColor = C'255,152,0';
    }
    ObjectSetString(0, "PC_ValTradeStatus", OBJPROP_TEXT, tradeStatus);
    ObjectSetInteger(0, "PC_ValTradeStatus", OBJPROP_COLOR, statusColor);
    
    // ポジション情報
    ObjectSetString(0, "PC_ValPosCount", OBJPROP_TEXT, IntegerToString(positionCount));
    ObjectSetString(0, "PC_ValPL", OBJPROP_TEXT, IntegerToString((int)totalProfit) + "円");
    ObjectSetInteger(0, "PC_ValPL", OBJPROP_COLOR, totalProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    ObjectSetString(0, "PC_ValPips", OBJPROP_TEXT, DoubleToString(totalPips, 1));
    ObjectSetInteger(0, "PC_ValPips", OBJPROP_COLOR, totalPips >= 0 ? C'76,175,80' : C'244,67,54');
    
    ObjectSetString(0, "PC_ValAuto", OBJPROP_TEXT, EnableAutoClose ? "ON" : "OFF");
    ObjectSetInteger(0, "PC_ValAuto", OBJPROP_COLOR, EnableAutoClose ? C'76,175,80' : C'100,100,100');
    
    // 統計情報
    double winRate = stats.totalTrades > 0 ? (double)stats.winTrades / stats.totalTrades * 100 : 0;
    double avgRR = stats.winTrades > 0 ? stats.totalRR / stats.winTrades : 0;
    
    ObjectSetString(0, "PC_ValWinRate", OBJPROP_TEXT, DoubleToString(winRate, 1) + "%");
    ObjectSetString(0, "PC_ValAvgRR", OBJPROP_TEXT, DoubleToString(avgRR, 1));
    ObjectSetString(0, "PC_ValWeekly", OBJPROP_TEXT, IntegerToString((int)stats.weeklyProfit) + "円");
    ObjectSetInteger(0, "PC_ValWeekly", OBJPROP_COLOR, stats.weeklyProfit >= 0 ? C'76,175,80' : C'244,67,54');
    ObjectSetString(0, "PC_ValMonthly", OBJPROP_TEXT, IntegerToString((int)stats.monthlyProfit) + "円");
    ObjectSetInteger(0, "PC_ValMonthly", OBJPROP_COLOR, stats.monthlyProfit >= 0 ? C'76,175,80' : C'244,67,54');
    
    // LOT計算結果
    ObjectSetString(0, "PC_ValCalcRisk", OBJPROP_TEXT, 
        riskAmount > 0 ? IntegerToString((int)riskAmount) + "円" : "---");
    ObjectSetString(0, "PC_ValCalcLot", OBJPROP_TEXT, 
        calculatedLot > 0 ? DoubleToString(calculatedLot, 2) : "---");
    
    // 推奨リスク額の表示
    ObjectSetString(0, "PC_ValRecommend", OBJPROP_TEXT, 
        recommendedRiskAmount > 0 ? IntegerToString((int)recommendedRiskAmount) + "円 (" + 
        DoubleToString(currentRiskPercent / DailyTradeLimit, 2) + "%)" : "---");
    
    // ビジュアル要素の更新
    UpdateProgressBar("PC_PhaseProgress", GetPhaseProgress());
    UpdateProgressBar("PC_RiskGauge", GetRiskUsageRate());
}

//+------------------------------------------------------------------+
//| 全ポジション決済                                                 |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 利益ポジションのみ決済                                           |
//+------------------------------------------------------------------+
void CloseProfitPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol && position.Profit() > 0)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " 利益ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 損失ポジションのみ決済                                           |
//+------------------------------------------------------------------+
void CloseLossPositions()
{
    int closed = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol && position.Profit() < 0)
            {
                trade.PositionClose(position.Ticket());
                closed++;
            }
        }
    }
    
    if(closed > 0)
        Alert(IntegerToString(closed) + " 損失ポジションを決済しました");
}

//+------------------------------------------------------------------+
//| 建値ストップ移動                                                 |
//+------------------------------------------------------------------+
void MoveAllToBreakeven()
{
    int modified = 0;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * point;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double openPrice = position.PriceOpen();
                double currentPrice = position.PriceCurrent();
                double currentSL = position.StopLoss();
                
                // 20pips以上の利益で建値に移動
                double threshold = 20 * point * 10;
                
                if(position.PositionType() == POSITION_TYPE_BUY)
                {
                    if(currentPrice - openPrice > threshold && currentSL < openPrice)
                    {
                        if(trade.PositionModify(position.Ticket(), openPrice + spread, position.TakeProfit()))
                            modified++;
                    }
                }
                else
                {
                    if(openPrice - currentPrice > threshold && (currentSL > openPrice || currentSL == 0))
                    {
                        if(trade.PositionModify(position.Ticket(), openPrice - spread, position.TakeProfit()))
                            modified++;
                    }
                }
            }
        }
    }
    
    if(modified > 0)
        Alert(IntegerToString(modified) + " ポジションを建値ストップに移動しました");
}

//+------------------------------------------------------------------+
//| 自動決済チェック                                                 |
//+------------------------------------------------------------------+
void CheckAutoClose()
{
    if(!EnableAutoClose) return;
    
    // 条件チェック
    bool shouldClose = false;
    string reason = "";
    
    if(totalPips >= AutoClosePips)
    {
        shouldClose = true;
        reason = "目標pips達成: " + DoubleToString(totalPips, 1) + "pips";
    }
    else if(totalProfit >= AutoCloseMoney)
    {
        shouldClose = true;
        reason = "目標金額達成: " + DoubleToString(totalProfit, 0) + "円";
    }
    
    // 自動決済実行
    if(shouldClose && positionCount > 0)
    {
        if(CloseOnlyProfit)
            CloseProfitPositions();
        else
            CloseAllPositions();
            
        Alert("自動決済実行: " + reason);
    }
}

//+------------------------------------------------------------------+
//| 日次リセットチェック                                             |
//+------------------------------------------------------------------+
void CheckDailyReset()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime currentTimeStruct, lastTimeStruct;
    TimeToStruct(currentTime, currentTimeStruct);
    TimeToStruct(lastDayCheck, lastTimeStruct);
    
    // 日付が変わったかチェック
    if(lastDayCheck != 0 && currentTimeStruct.day_of_year != lastTimeStruct.day_of_year)
    {
        todayTradeCount = 0;
        todayProfit = 0;
        lastDayCheck = currentTime;
        Alert("新しい取引日が始まりました");
    }
}

//+------------------------------------------------------------------+
//| 統計情報の保存                                                   |
//+------------------------------------------------------------------+
void SaveTradeStats()
{
    GlobalVariableSet("PC_TotalTrades", stats.totalTrades);
    GlobalVariableSet("PC_WinTrades", stats.winTrades);
    GlobalVariableSet("PC_TotalRR", stats.totalRR);
    GlobalVariableSet("PC_WeeklyProfit", stats.weeklyProfit);
    GlobalVariableSet("PC_MonthlyProfit", stats.monthlyProfit);
}

//+------------------------------------------------------------------+
//| 統計情報の読み込み                                               |
//+------------------------------------------------------------------+
void LoadTradeStats()
{
    if(GlobalVariableCheck("PC_TotalTrades"))
        stats.totalTrades = (int)GlobalVariableGet("PC_TotalTrades");
    if(GlobalVariableCheck("PC_WinTrades"))
        stats.winTrades = (int)GlobalVariableGet("PC_WinTrades");
    if(GlobalVariableCheck("PC_TotalRR"))
        stats.totalRR = GlobalVariableGet("PC_TotalRR");
    if(GlobalVariableCheck("PC_WeeklyProfit"))
        stats.weeklyProfit = GlobalVariableGet("PC_WeeklyProfit");
    if(GlobalVariableCheck("PC_MonthlyProfit"))
        stats.monthlyProfit = GlobalVariableGet("PC_MonthlyProfit");
}

//+------------------------------------------------------------------+
//| プログレスバー作成関数                                           |
//+------------------------------------------------------------------+
void CreateProgressBar(string name, int x, int y, int w, int h, double percent, 
                      color fillColor, color bgColor)
{
    // 背景
    string bgName = name + "_bg";
    CreateRect(bgName, x, y, w, h, bgColor);
    
    // 進捗バー
    string fillName = name + "_fill";
    int fillWidth = (int)(w * percent / 100);
    if(fillWidth > 0)
    {
        CreateRect(fillName, x, y, fillWidth, h, fillColor);
    }
    
    // パーセント表示
    string textName = name + "_text";
    CreateLabel(textName, x + w/2, y + h/2 - 7, 
                DoubleToString(percent, 1) + "%", 10, clrWhite, "Arial Bold", ANCHOR_CENTER);
}

//+------------------------------------------------------------------+
//| フェーズ進捗率計算                                               |
//+------------------------------------------------------------------+
double GetPhaseProgress()
{
    double progress = 0;
    
    switch(currentPhase)
    {
        case 1:
            progress = (accountBalance - 5000) / (20000 - 5000) * 100;
            break;
        case 2:
            progress = (accountBalance - 20000) / (50000 - 20000) * 100;
            break;
        case 3:
            progress = (accountBalance - 50000) / (150000 - 50000) * 100;
            break;
        case 4:
            progress = (accountBalance - 150000) / (500000 - 150000) * 100;
            break;
        case 5:
            progress = (accountBalance - 500000) / (1000000 - 500000) * 100;
            break;
    }
    
    return MathMax(0, MathMin(100, progress));
}

//+------------------------------------------------------------------+
//| リスク使用率計算                                                 |
//+------------------------------------------------------------------+
double GetRiskUsageRate()
{
    if(currentMaxRisk == 0) return 0;
    
    // 現在のポジションの合計リスクを計算
    double totalRisk = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(position.SelectByIndex(i))
        {
            if(position.Symbol() == _Symbol)
            {
                double positionRisk = MathAbs(position.PriceOpen() - position.StopLoss()) * 
                                    position.Volume() * 
                                    SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE) * 10;
                totalRisk += positionRisk;
            }
        }
    }
    
    return (totalRisk / currentMaxRisk) * 100;
}

//+------------------------------------------------------------------+
//| プログレスバー更新                                               |
//+------------------------------------------------------------------+
void UpdateProgressBar(string name, double percent)
{
    // バーの幅を更新
    string fillName = name + "_fill";
    if(ObjectFind(0, fillName) >= 0)
    {
        int bgWidth = (int)ObjectGetInteger(0, name + "_bg", OBJPROP_XSIZE);
        int fillWidth = (int)(bgWidth * percent / 100);
        ObjectSetInteger(0, fillName, OBJPROP_XSIZE, fillWidth);
    }
    
    // テキスト更新
    string textName = name + "_text";
    if(ObjectFind(0, textName) >= 0)
    {
        ObjectSetString(0, textName, OBJPROP_TEXT, DoubleToString(percent, 1) + "%");
    }
}

//+------------------------------------------------------------------+
